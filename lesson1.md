Часть I. Осваиваем синтаксис

Задание 1. filter и exclude в одном вызове  
После применения миграций в Django доступна модель django.contrib.auth.models.User. Пусть нам нужно выбрать из этой модели 
таких пользователей, которые входят в набор доверенных пользователей (is_staff), но указали email не из домена @gmail.com
Запрос к базе данных, в этом случае, можно построить так:
```python
User.objects.filter(is_staff=True).exlude(email__endswith='@gmail.com')

``` 
Перепишите этот запрос используя Q и не используя exclude
```python
User.objects.filter(Q(is_staff=True) & ~Q(email__endswith='@gmail.com'))
```

Задание 2. Объединение по условию ИЛИ  
Напишите запрос к модели User, в котором будут выбраны все пользователи с email из домена '@mail.ru' или '@yandex.ru'
```python
User.objects.filter(Q(email__endswith='@mail.ru') | Q(email__endswith='@yandex.ru'))
```

Задание 3. Группировка условий  
Создайте такой позиционный аргумент к методу User.objects.filter, который позволит выбрать всех пользователей username 
которых содержит слово admin или moderator, но, при этом, не явлются привелигированными (is_staff или is_superuser)
```python
arg = Q(Q(username__ilike='admin') | Q(username__ilike='moderator')) & ~Q(Q(is_staff=True) & Q(is_superuser=True))
User.objects.filter(arg)
```

Задание 4. Композиция  
Создайте такой позиционный аргумент к методу User.objects.filter, который будет искать пользователей по их username 
по заранее неизвестному списку строк. В этом списке могут быть не полные username.
```python
usernames_to_find = ['Ivan', 'petr', 'sidoro']
arg = Q()
for name in usernames_to_find:
    arg |= Q(username__ilike=name)
User.objects.filter(arg)
```

Задание 5. Поиск по динамическому полю  
Создайте такой позиционный аргумент к методу User.objects.filter, который будет искать пользователей по заранее неизвестному 
полю, значения которого берутся из заранее неизвестного списка

```python
field_name = 'email' # но может быть и 'username' и 'first_name' и 'last_name'
field_values = ['@gmail.com', 'admin', 'Сидоров', 'Вася']

arg = Q()

for value in field_values:
    expression = {f"{field_name}__ilike": value}
    arg |= Q(**expression)
User.objects.filter(arg)
```

Часть II. Работаем с данными 

Организация, проводящая турнир по стрельбе из пневматичекой винтовки попросила вас о помощи с программой для хранения 
и подсчета результатов стрельб.

В турнире участвали стрелки (shooting1.models.Shooter) из разных городов (shooting1.models.City). Для каждого стрелка 
организаторы турнира внесли результаты его стрельбы в модель shooting1.models.Result

Затем, в модуле shooting1.results_viewer они написали функцию show_results, которая выводит в терминал таблицу результатов.

Но после проведения турнира оказалось, что результатов стрелков из Москвы слишком много и из таблицы решили убрать 
такие результаты москвичей, которые были меньше 380. Но тогда в таблицу не попал результат сына мера Москвы Виктора,
который набрал 379 очков.

К сожалению, у программиста, который писал программу вывода результатов заболела кошка и дописать ее попросили вас.

Задание 1.
Нужно составить такой запрос к базе данных, чтобы в таблицу результатов попал результат Виктора, но остальные слабые 
результаты москвичей по-прежнему не показывались.

Задание 2.
Как вы заметили, в поле name модели shooting1.models.Result на самом деле оказались записаны фамилия и имя стрелка. 
Требуется вывести такой отчет, чтобы в нем оказались только стрелки с именем Максим или Марк

Задание 3.
Оказалось, что задание 2 не очень гибкое. Перепишите функцию так, чтобы она принимала произвольный список имен 
и выводила отчет с результатами стрельб только игроков с этими именами.

Задание 4.
Один из разработчиков программы для просмотра отчетов написал функцию get_filtered_results, которая принимает несколько аргуметов для 
фильтрации отчета. Можно искать по заданному списку городов, имени или фамилии стрелка и задать границу набранных 
очков ниже которой отчет не показывается для краткости. Из книги по рефакторингу он узнал, что сложные запросы к 
базе данных лучше разделять на агрегирующую, фильтрующую, сортирующую и лимитирующие части. Тогда их легче поддерживать. 
 Начать он решил с выделения фильрующей части и написал для этого отдельную функцию filter_results_queryset. К сожалению, 
 IDE плохо помогает с исправлением опечаток в ней и, вообще, на выхоже получается словарь, а не что-то похожее на запрос. 
 Вы уже знаете как использовать объект Q - попробуйте переписать эту функцию используя Q. 

Задание 5.
Москвичи попросили вас найти среди результатов только очень хорошие или очень плохие результаты, чтобы было ясно кого 
наградить а кого наказать.
Используя объект Q, напишите такой запрос в котором будут показаны только результаты больше 390 или меньше 240
 у стрелков из Москвы
 

Замечания:

Корректным решением задания является создание одного запроса к базе данных с использование объекта Q в Django ORM

Для того, чтобы загрузить в текущую базу данных результаты стрельб выполните следующую management команду:

```python
manage.py init_lesson1
```

Чтобы построить отчет от стрельбах, выполните следующую management команду:

```python
manage.py show_results1 results_viewer.get_results1
```

По мере продвижения по заданиям выполняйте нужные функции из shooting1.results_viewer по аналогии с предыдущей командой:

```python
manage.py show_results1 results_viewer.get_results2
manage.py show_results1 results_viewer.get_results3
...
manage.py show_results1 results_viewer.get_filtered_results

```
